import {
  BaseClient,
  parseOrThrow,
  type Parsed,
  type RequestParams,
} from "./base-client";
import {
  SandboxAndRoutesResponse,
  SandboxResponse,
  CommandResponse,
  CommandFinishedResponse,
  EmptyResponse,
  LogLine,
  SandboxesResponse,
} from "./validators";
import { APIError } from "./api-error";
import { FileWriter } from "./file-writer";
import { VERSION } from "../version";
import { consumeReadable } from "../utils/consume-readable";
import { z } from "zod";
import jsonlines from "jsonlines";
import os from "os";
import { Readable } from "stream";
import { normalizePath } from "../utils/normalizePath";
import { JwtExpiry } from "../utils/jwt-expiry";
import { getPrivateParams, WithPrivate } from "../utils/types";

export class APIClient extends BaseClient {
  private teamId: string;
  private tokenExpiry: JwtExpiry | null;

  constructor(params: { host?: string; teamId: string; token: string }) {
    super({
      host: params.host ?? "https://api.vercel.com",
      token: params.token,
      debug: false,
    });

    this.teamId = params.teamId;
    this.tokenExpiry = JwtExpiry.fromToken(params.token);
  }

  private async ensureValidToken(): Promise<void> {
    if (!this.tokenExpiry) {
      return;
    }

    const newExpiry = await this.tokenExpiry.tryRefresh();
    if (!newExpiry) {
      return;
    }

    this.tokenExpiry = newExpiry;
    this.token = this.tokenExpiry.token;
    if (this.tokenExpiry.payload) {
      this.teamId = this.tokenExpiry.payload?.owner_id;
    }
  }

  protected async request(path: string, params?: RequestParams) {
    await this.ensureValidToken();

    return super.request(path, {
      ...params,
      query: { teamId: this.teamId, ...params?.query },
      headers: {
        "content-type": "application/json",
        "user-agent": `vercel/sandbox/${VERSION} (Node.js/${process.version}; ${os.platform()}/${os.arch()})`,
        ...params?.headers,
      },
    });
  }

  async getSandbox(params: { sandboxId: string }) {
    return parseOrThrow(
      SandboxAndRoutesResponse,
      await this.request(`/v1/sandboxes/${params.sandboxId}`),
    );
  }

  async createSandbox(
    params: WithPrivate<{
      ports?: number[];
      projectId: string;
      source?:
        | {
            type: "git";
            url: string;
            depth?: number;
            revision?: string;
            username?: string;
            password?: string;
          }
        | { type: "tarball"; url: string };
      timeout?: number;
      resources?: { vcpus: number };
      runtime?: "node22" | "python3.13" | (string & {});
    }>,
  ) {
    const privateParams = getPrivateParams(params);
    return parseOrThrow(
      SandboxAndRoutesResponse,
      await this.request("/v1/sandboxes", {
        method: "POST",
        body: JSON.stringify({
          projectId: params.projectId,
          ports: params.ports,
          source: params.source,
          timeout: params.timeout,
          resources: params.resources,
          runtime: params.runtime,
          ...privateParams,
        }),
      }),
    );
  }

  async runCommand(params: {
    sandboxId: string;
    cwd?: string;
    command: string;
    args: string[];
    env: Record<string, string>;
    sudo: boolean;
  }) {
    return parseOrThrow(
      CommandResponse,
      await this.request(`/v1/sandboxes/${params.sandboxId}/cmd`, {
        method: "POST",
        body: JSON.stringify({
          command: params.command,
          args: params.args,
          cwd: params.cwd,
          env: params.env,
          sudo: params.sudo,
        }),
      }),
    );
  }

  async getCommand(params: {
    sandboxId: string;
    cmdId: string;
    wait: true;
  }): Promise<Parsed<z.infer<typeof CommandFinishedResponse>>>;
  async getCommand(params: {
    sandboxId: string;
    cmdId: string;
    wait?: boolean;
  }): Promise<Parsed<z.infer<typeof CommandResponse>>>;
  async getCommand(params: {
    sandboxId: string;
    cmdId: string;
    wait?: boolean;
  }) {
    return params.wait
      ? parseOrThrow(
          CommandFinishedResponse,
          await this.request(
            `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`,
            { query: { wait: "true" } },
          ),
        )
      : parseOrThrow(
          CommandResponse,
          await this.request(
            `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`,
          ),
        );
  }

  async mkDir(params: { sandboxId: string; path: string; cwd?: string }) {
    return parseOrThrow(
      EmptyResponse,
      await this.request(`/v1/sandboxes/${params.sandboxId}/fs/mkdir`, {
        method: "POST",
        body: JSON.stringify({ path: params.path, cwd: params.cwd }),
      }),
    );
  }

  getFileWriter(params: { sandboxId: string; extractDir: string }) {
    const writer = new FileWriter();
    return {
      response: (async () => {
        return this.request(`/v1/sandboxes/${params.sandboxId}/fs/write`, {
          method: "POST",
          headers: {
            "content-type": "application/gzip",
            "x-cwd": params.extractDir,
          },
          body: await consumeReadable(writer.readable),
        });
      })(),
      writer,
    };
  }

  async listSandboxes(params: {
    /**
     * The ID or name of the project to which the sandboxes belong.
     * @example "my-project"
     */
    projectId: string;
    /**
     * Maximum number of sandboxes to list from a request.
     * @example 10
     */
    limit?: number;
    /**
     * Get sandboxes created after this JavaScript timestamp.
     * @example 1540095775941
     */
    since?: number | Date;
    /**
     * Get sandboxes created before this JavaScript timestamp.
     * @example 1540095775951
     */
    until?: number | Date;
  }) {
    return parseOrThrow(
      SandboxesResponse,
      await this.request(`/v1/sandboxes`, {
        query: {
          project: params.projectId,
          limit: params.limit,
          since:
            typeof params.since === "number"
              ? params.since
              : params.since?.getTime(),
          until:
            typeof params.until === "number"
              ? params.until
              : params.until?.getTime(),
        },
        method: "GET",
      }),
    );
  }

  async writeFiles(params: {
    sandboxId: string;
    cwd: string;
    files: { path: string; content: Buffer }[];
    extractDir: string;
  }) {
    const { writer, response } = this.getFileWriter({
      sandboxId: params.sandboxId,
      extractDir: params.extractDir,
    });

    for (const file of params.files) {
      await writer.addFile({
        name: normalizePath({
          filePath: file.path,
          extractDir: params.extractDir,
          cwd: params.cwd,
        }),
        content: file.content,
      });
    }

    writer.end();
    await parseOrThrow(EmptyResponse, await response);
  }

  async readFile(params: {
    sandboxId: string;
    path: string;
    cwd?: string;
  }): Promise<NodeJS.ReadableStream | null> {
    const response = await this.request(
      `/v1/sandboxes/${params.sandboxId}/fs/read`,
      {
        method: "POST",
        body: JSON.stringify({ path: params.path, cwd: params.cwd }),
      },
    );

    if (response.status === 404) {
      return null;
    }

    if (response.body === null) {
      return null;
    }

    return Readable.fromWeb(response.body);
  }

  async killCommand(params: {
    sandboxId: string;
    commandId: string;
    signal: number;
  }) {
    return parseOrThrow(
      CommandResponse,
      await this.request(
        `/v1/sandboxes/${params.sandboxId}/${params.commandId}/kill`,
        {
          method: "POST",
          body: JSON.stringify({ signal: params.signal }),
        },
      ),
    );
  }

  getLogs(params: {
    sandboxId: string;
    cmdId: string;
    signal?: AbortSignal;
  }): AsyncGenerator<z.infer<typeof LogLine>, void, void> &
    Disposable & { close(): void } {
    const self = this;
    const disposer = new AbortController();

    const signal = !params.signal
      ? disposer.signal
      : mergeSignals(params.signal, disposer.signal);

    const generator = (async function* () {
      const url = `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}/logs`;
      const response = await self.request(url, {
        method: "GET",
        signal,
      });
      if (response.headers.get("content-type") !== "application/x-ndjson") {
        throw new APIError(response, {
          message: "Expected a stream of logs",
        });
      }

      if (response.body === null) {
        throw new APIError(response, {
          message: "No response body",
        });
      }

      const jsonlinesStream = jsonlines.parse();
      pipe(response.body, jsonlinesStream).catch((err) => {
        console.error("Error piping logs:", err);
      });

      for await (const chunk of jsonlinesStream) {
        yield LogLine.parse(chunk);
      }
    })();

    return Object.assign(generator, {
      [Symbol.dispose]() {
        disposer.abort("Disposed");
      },
      close: () => disposer.abort("Disposed"),
    });
  }

  async stopSandbox(params: {
    sandboxId: string;
  }): Promise<Parsed<z.infer<typeof SandboxResponse>>> {
    const url = `/v1/sandboxes/${params.sandboxId}/stop`;
    return parseOrThrow(
      SandboxResponse,
      await this.request(url, { method: "POST" }),
    );
  }
}

async function pipe(
  readable: ReadableStream<Uint8Array>,
  output: NodeJS.WritableStream,
) {
  const reader = readable.getReader();
  try {
    while (true) {
      const read = await reader.read();
      if (read.value) {
        output.write(Buffer.from(read.value));
      }
      if (read.done) {
        break;
      }
    }
  } catch (err) {
    output.emit("error", err);
  } finally {
    output.end();
  }
}

function mergeSignals(...signals: [AbortSignal, ...AbortSignal[]]) {
  const controller = new AbortController();
  const onAbort = () => {
    controller.abort();
    for (const signal of signals) {
      signal.removeEventListener("abort", onAbort);
    }
  };
  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort();
      break;
    }
    signal.addEventListener("abort", onAbort);
  }
  return controller.signal;
}
